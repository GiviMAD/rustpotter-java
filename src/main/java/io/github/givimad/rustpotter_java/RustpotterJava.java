// Automatically generated by flapigen
package io.github.givimad.rustpotter_java;


public final class RustpotterJava {

    private RustpotterJava() {}
    /**
     * Process i32 audio chunks.
     * 
     * Asserts that the audio chunk length should match the return
     * of the get_samples_per_frame method.
     * 
     * Assumes sample rate match the configured for the detector.
     * 
     * Asserts that detector bits_per_sample is one of: 8, 16, 24, 32.
     * 
     * Asserts that detector sample_format is 'int'.
     * 
     * It's an alias for the processInt method.
     */
    public final java.util.Optional<RustpotterDetection> process(int [] buffer) {
        long ret = do_process(mNativeObj, buffer);
        java.util.Optional<RustpotterDetection> convRet;
        if (ret != 0) {
            convRet = java.util.Optional.of(new RustpotterDetection(InternalPointerMarker.RAW_PTR, ret));
        } else {
            convRet = java.util.Optional.empty();
        }

        return convRet;
    }
    private static native long do_process(long self, int [] buffer);
    /**
     * Process i32 audio chunks.
     * 
     * Asserts that the audio chunk length should match the return
     * of the get_samples_per_frame method.
     * 
     * Assumes sample rate match the configured for the detector.
     * 
     * Asserts that detector bits_per_sample is one of: 8, 16, 24, 32.
     * 
     * Asserts that detector sample_format is 'int'.
     */
    public final java.util.Optional<RustpotterDetection> processInt(int [] buffer) {
        long ret = do_processInt(mNativeObj, buffer);
        java.util.Optional<RustpotterDetection> convRet;
        if (ret != 0) {
            convRet = java.util.Optional.of(new RustpotterDetection(InternalPointerMarker.RAW_PTR, ret));
        } else {
            convRet = java.util.Optional.empty();
        }

        return convRet;
    }
    private static native long do_processInt(long self, int [] buffer);
    /**
     * Process i16 audio chunks.
     * 
     * Asserts that the audio chunk length should match the return
     * of the get_samples_per_frame method.
     * 
     * Assumes sample rate match the configured for the detector.
     * 
     * Asserts that detector bits_per_sample is one of: 8, 16.
     * 
     * Asserts that detector sample_format is 'int'.
     */
    public final java.util.Optional<RustpotterDetection> processSort(short [] buffer) {
        long ret = do_processSort(mNativeObj, buffer);
        java.util.Optional<RustpotterDetection> convRet;
        if (ret != 0) {
            convRet = java.util.Optional.of(new RustpotterDetection(InternalPointerMarker.RAW_PTR, ret));
        } else {
            convRet = java.util.Optional.empty();
        }

        return convRet;
    }
    private static native long do_processSort(long self, short [] buffer);
    /**
     * Process i8 audio chunks.
     * 
     * Asserts that the audio chunk length should match the return
     * of the get_samples_per_frame method.
     * 
     * Assumes sample rate match the configured for the detector.
     * 
     * Asserts that detector bits_per_sample is 8.
     * 
     * Asserts that detector sample_format is 'int'.
     */
    public final java.util.Optional<RustpotterDetection> processByte(byte [] buffer) {
        long ret = do_processByte(mNativeObj, buffer);
        java.util.Optional<RustpotterDetection> convRet;
        if (ret != 0) {
            convRet = java.util.Optional.of(new RustpotterDetection(InternalPointerMarker.RAW_PTR, ret));
        } else {
            convRet = java.util.Optional.empty();
        }

        return convRet;
    }
    private static native long do_processByte(long self, byte [] buffer);
    /**
     * Process f32 audio chunks.
     * 
     * Asserts that the audio chunk length should match the return
     * of the get_samples_per_frame method.
     * 
     * Assumes sample rate match the configured for the detector.
     * 
     * Asserts that detector bits_per_sample is 32.
     * 
     * Asserts that detector sample_format is 'float'.
     */
    public final java.util.Optional<RustpotterDetection> processFloat(float [] buffer) {
        long ret = do_processFloat(mNativeObj, buffer);
        java.util.Optional<RustpotterDetection> convRet;
        if (ret != 0) {
            convRet = java.util.Optional.of(new RustpotterDetection(InternalPointerMarker.RAW_PTR, ret));
        } else {
            convRet = java.util.Optional.empty();
        }

        return convRet;
    }
    private static native long do_processFloat(long self, float [] buffer);
    /**
     * Loads a wakeword from its model path.
     */
    public final void addWakewordModelFile(String path) {
        do_addWakewordModelFile(mNativeObj, path);
    }
    private static native void do_addWakewordModelFile(long self, String path);
    /**
     * Returns the desired chunk size.
     */
    public final long getFrameSize() {
        long ret = do_getFrameSize(mNativeObj);

        return ret;
    }
    private static native long do_getFrameSize(long self);

    public synchronized void delete() {
        if (mNativeObj != 0) {
            do_delete(mNativeObj);
            mNativeObj = 0;
       }
    }
    @Override
    protected void finalize() throws Throwable {
        try {
            delete();
        }
        finally {
             super.finalize();
        }
    }
    private static native void do_delete(long me);
    /*package*/ RustpotterJava(InternalPointerMarker marker, long ptr) {
        assert marker == InternalPointerMarker.RAW_PTR;
        this.mNativeObj = ptr;
    }
    /*package*/ long mNativeObj;

    public static void loadLibrary() {
        try {
            String osName = System.getProperty("os.name").toLowerCase();
            String osArch = System.getProperty("os.arch").toLowerCase();
            if (osName.contains("win")) {
                if(osArch.contains("amd64") || osArch.contains("x86_64")) {
                    NativeUtils.loadLibraryFromJar("/librustpotter_java_win_x86_64.dll");
                    return;
                }
            } else if (osName.contains("nix") || osName.contains("nux")
                    || osName.contains("aix")) {
                if(osArch.contains("amd64") || osArch.contains("x86_64")) {
                    NativeUtils.loadLibraryFromJar("/librustpotter_java_debian_x86_64.so");
                    return;
                } else if(osArch.contains("aarch64") || osArch.contains("arm64")) {
                    NativeUtils.loadLibraryFromJar("/librustpotter_java_debian_aarch64.so");
                    return;
                } else if(osArch.contains("armv7") || osArch.contains("arm")) {
                    NativeUtils.loadLibraryFromJar("/librustpotter_java_debian_armv7l.so");
                    return;
                }
            } else if (osName.contains("mac") || osName.contains("darwin")) {
                if(osArch.contains("amd64") || osArch.contains("x86_64")) {
                    NativeUtils.loadLibraryFromJar("/librustpotter_java_macos_x86_64.dylib");
                    return;
                } else if(osArch.contains("aarch64") || osArch.contains("arm64")) {
                    NativeUtils.loadLibraryFromJar("/librustpotter_java_macos_aarch64.dylib");
                    return;
                }
            }
            throw new java.io.IOException("Rustpotter: Unsupported platform.");
        } catch (java.io.IOException e) {
            e.printStackTrace();
        }
    }
}